// Generated by Sideko (sideko.dev)
package postman_api

import (
"bytes"
"encoding/json"
	"fmt"
	"io"
    "mime/multipart"
	"net/http"
	"net/url"
    "os"
	"path/filepath"
	"strconv"
	"time"
)

func anyToString(value interface{}) string {
	switch v := value.(type) {
	case int:
		return strconv.Itoa(v)
	case int64:
		return strconv.FormatInt(v, 10)
	case float64:
		return strconv.FormatFloat(v, 'f', -1, 64)
	case string:
		return v
	default:
		return fmt.Sprintf("%v", v)
	}
}

func addFileToFormDataWriter(writer *multipart.Writer, field string, filePath string) error {
	file, err := os.Open(filePath)
	if err != nil {
		return err
	}

	part, err := writer.CreateFormFile(field, filepath.Base(file.Name()))
	if err != nil {
		return err
	}

	_, err = io.Copy(part, file)
	if err != nil {
		return err
	}

	fmt.Printf("copied %v", part)

	return nil
}

func addFieldToFormDataWriter(writer *multipart.Writer, field string, value any) error {
	label, err := writer.CreateFormField(field)
	if err != nil {
		return err
	}
	label.Write([]byte(anyToString(value)))
	return nil
}

type RequestError struct {
	StatusCode int
	Method     string
	Url        string
	Data       any
	Request    http.Request
	Response   http.Response
}

func NewRequestError(request http.Request, response http.Response) RequestError {
	body, _ := io.ReadAll(response.Body)
	var unmarshaled any
	err := json.Unmarshal(body, &unmarshaled)
	if err != nil {
		return RequestError{
			StatusCode: response.StatusCode,
			Method:     request.Method,
			Url:        request.URL.String(),
			Data:       string(body),
			Request:    request,
			Response:   response,
		}
	}

	return RequestError{
		StatusCode: response.StatusCode,
		Method:     request.Method,
		Url:        request.URL.String(),
		Data:       unmarshaled,
		Request:    request,
		Response:   response,
	}
}

func (e RequestError) Error() string {
	return fmt.Sprintf("RequestError: received %d from %s %s", e.StatusCode, e.Method, e.Url)
}

func errorForStatus(request http.Request, response http.Response) error {
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return NewRequestError(request, response)
	}
	return nil
}

type SidekoClient struct {
	httpClient *http.Client
	baseUrl    string
	username   string
	password   string
    token      string
    apiKey     string
}

// Instantiate a new API client
func NewSidekoClient(apiKey string) *SidekoClient {
    baseUrl := `https://api.getpostman.com`
    httpClient := http.Client{Timeout: time.Duration(3) * time.Second}

    client := SidekoClient{httpClient: &httpClient, baseUrl: baseUrl, apiKey: apiKey}
	return &client
}

// Updates base url of API client
func (c *SidekoClient) SetBaseUrl(url string) {
	c.baseUrl = url
}

// Returns base url of API client
func (c *SidekoClient) BaseUrl() string {
	return c.baseUrl
}

// Updates token of API client
func (c *SidekoClient) SetToken(token string) {
	c.token = token
}

// Sets request timeout of client
func (c *SidekoClient) SetTimeout(timeout time.Duration) {
	httpClient := http.Client{Timeout: timeout}
	c.httpClient = &httpClient
}

// Returns timeout
func (c *SidekoClient) Timeout() time.Duration {
	return c.httpClient.Timeout
}

func (c *SidekoClient) DeleteApi(request DeleteApisApiIdRequest) (any, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/apis/"+anyToString(request.APIID))
    if err != nil {
        return 0, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return 0, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "DELETE",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return 0, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return 0, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return 0, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return 0, err
    }

    var castedBody any
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return 0, err
    }
    return castedBody, nil
}
func (c *SidekoClient) DeleteSchemaFile(request DeleteApisApiIdSchemasSchemaIdFilesFilePathRequest) (any, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/apis/"+anyToString(request.APIID)+"/schemas/"+anyToString(request.SchemaID)+"/files/"+anyToString(request.FilePath))
    if err != nil {
        return 0, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return 0, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "DELETE",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return 0, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return 0, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return 0, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return 0, err
    }

    var castedBody any
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return 0, err
    }
    return castedBody, nil
}
func (c *SidekoClient) DeleteApiVersion(request DeleteApisApiIdVersionsVersionIdRequest) (any, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/apis/"+anyToString(request.APIID)+"/versions/"+anyToString(request.VersionID))
    if err != nil {
        return 0, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return 0, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "DELETE",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return 0, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return 0, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return 0, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return 0, err
    }

    var castedBody any
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return 0, err
    }
    return castedBody, nil
}
func (c *SidekoClient) DeleteCollection(request DeleteCollectionsCollectionIdRequest) (DeleteCollectionsCollectionIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/collections/"+anyToString(request.CollectionID))
    if err != nil {
        return DeleteCollectionsCollectionIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return DeleteCollectionsCollectionIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "DELETE",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return DeleteCollectionsCollectionIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return DeleteCollectionsCollectionIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return DeleteCollectionsCollectionIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return DeleteCollectionsCollectionIDResponse{}, err
    }

    var castedBody DeleteCollectionsCollectionIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return DeleteCollectionsCollectionIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) DeleteCollectionFolder(request DeleteCollectionsCollectionIdFoldersFolderIdRequest) (DeleteCollectionsCollectionIDFoldersFolderIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/collections/"+anyToString(request.CollectionID)+"/folders/"+anyToString(request.FolderID))
    if err != nil {
        return DeleteCollectionsCollectionIDFoldersFolderIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return DeleteCollectionsCollectionIDFoldersFolderIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "DELETE",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return DeleteCollectionsCollectionIDFoldersFolderIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return DeleteCollectionsCollectionIDFoldersFolderIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return DeleteCollectionsCollectionIDFoldersFolderIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return DeleteCollectionsCollectionIDFoldersFolderIDResponse{}, err
    }

    var castedBody DeleteCollectionsCollectionIDFoldersFolderIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return DeleteCollectionsCollectionIDFoldersFolderIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) DeleteCollectionRequest(request DeleteCollectionsCollectionIdRequestsRequestIdRequest) (DeleteCollectionsCollectionIDRequestsRequestIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/collections/"+anyToString(request.CollectionID)+"/requests/"+anyToString(request.RequestID))
    if err != nil {
        return DeleteCollectionsCollectionIDRequestsRequestIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return DeleteCollectionsCollectionIDRequestsRequestIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "DELETE",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return DeleteCollectionsCollectionIDRequestsRequestIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return DeleteCollectionsCollectionIDRequestsRequestIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return DeleteCollectionsCollectionIDRequestsRequestIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return DeleteCollectionsCollectionIDRequestsRequestIDResponse{}, err
    }

    var castedBody DeleteCollectionsCollectionIDRequestsRequestIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return DeleteCollectionsCollectionIDRequestsRequestIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) DeleteCollectionResponse(request DeleteCollectionsCollectionIdResponsesResponseIdRequest) (DeleteCollectionsCollectionIDResponsesResponseIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/collections/"+anyToString(request.CollectionID)+"/responses/"+anyToString(request.ResponseID))
    if err != nil {
        return DeleteCollectionsCollectionIDResponsesResponseIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return DeleteCollectionsCollectionIDResponsesResponseIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "DELETE",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return DeleteCollectionsCollectionIDResponsesResponseIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return DeleteCollectionsCollectionIDResponsesResponseIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return DeleteCollectionsCollectionIDResponsesResponseIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return DeleteCollectionsCollectionIDResponsesResponseIDResponse{}, err
    }

    var castedBody DeleteCollectionsCollectionIDResponsesResponseIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return DeleteCollectionsCollectionIDResponsesResponseIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) DeleteEnvironment(request DeleteEnvironmentsEnvironmentIdRequest) (DeleteEnvironmentsEnvironmentIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/environments/"+anyToString(request.EnvironmentID))
    if err != nil {
        return DeleteEnvironmentsEnvironmentIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return DeleteEnvironmentsEnvironmentIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "DELETE",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return DeleteEnvironmentsEnvironmentIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return DeleteEnvironmentsEnvironmentIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return DeleteEnvironmentsEnvironmentIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return DeleteEnvironmentsEnvironmentIDResponse{}, err
    }

    var castedBody DeleteEnvironmentsEnvironmentIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return DeleteEnvironmentsEnvironmentIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) DeleteMock(request DeleteMocksMockIdRequest) (DeleteMocksMockIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/mocks/"+anyToString(request.MockID))
    if err != nil {
        return DeleteMocksMockIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return DeleteMocksMockIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "DELETE",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return DeleteMocksMockIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return DeleteMocksMockIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return DeleteMocksMockIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return DeleteMocksMockIDResponse{}, err
    }

    var castedBody DeleteMocksMockIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return DeleteMocksMockIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) DeleteMockServerResponse(request DeleteMocksMockIdServerResponsesServerResponseIdRequest) (DeleteMocksMockIDServerResponsesServerResponseIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/mocks/"+anyToString(request.MockID)+"/server-responses/"+anyToString(request.ServerResponseID))
    if err != nil {
        return DeleteMocksMockIDServerResponsesServerResponseIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return DeleteMocksMockIDServerResponsesServerResponseIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "DELETE",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return DeleteMocksMockIDServerResponsesServerResponseIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return DeleteMocksMockIDServerResponsesServerResponseIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return DeleteMocksMockIDServerResponsesServerResponseIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return DeleteMocksMockIDServerResponsesServerResponseIDResponse{}, err
    }

    var castedBody DeleteMocksMockIDServerResponsesServerResponseIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return DeleteMocksMockIDServerResponsesServerResponseIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) UnpublishMock(request DeleteMocksMockIdUnpublishRequest) (DeleteMocksMockIDUnpublishResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/mocks/"+anyToString(request.MockID)+"/unpublish")
    if err != nil {
        return DeleteMocksMockIDUnpublishResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return DeleteMocksMockIDUnpublishResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "DELETE",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return DeleteMocksMockIDUnpublishResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return DeleteMocksMockIDUnpublishResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return DeleteMocksMockIDUnpublishResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return DeleteMocksMockIDUnpublishResponse{}, err
    }

    var castedBody DeleteMocksMockIDUnpublishResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return DeleteMocksMockIDUnpublishResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) DeleteMonitor(request DeleteMonitorsMonitorIdRequest) (DeleteMonitorsMonitorIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/monitors/"+anyToString(request.MonitorID))
    if err != nil {
        return DeleteMonitorsMonitorIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return DeleteMonitorsMonitorIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "DELETE",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return DeleteMonitorsMonitorIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return DeleteMonitorsMonitorIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return DeleteMonitorsMonitorIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return DeleteMonitorsMonitorIDResponse{}, err
    }

    var castedBody DeleteMonitorsMonitorIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return DeleteMonitorsMonitorIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) RemoveElementOrFolder(request DeleteNetworkPrivateElementTypeElementIdRequest) (DeleteNetworkPrivateElementTypeElementIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/network/private/"+anyToString(request.ElementType)+"/"+anyToString(request.ElementID))
    if err != nil {
        return DeleteNetworkPrivateElementTypeElementIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return DeleteNetworkPrivateElementTypeElementIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "DELETE",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return DeleteNetworkPrivateElementTypeElementIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return DeleteNetworkPrivateElementTypeElementIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return DeleteNetworkPrivateElementTypeElementIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return DeleteNetworkPrivateElementTypeElementIDResponse{}, err
    }

    var castedBody DeleteNetworkPrivateElementTypeElementIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return DeleteNetworkPrivateElementTypeElementIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) DeleteGroup(request DeleteScimV2GroupsGroupIdRequest) (any, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/scim/v2/Groups/"+anyToString(request.GroupID))
    if err != nil {
        return 0, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return 0, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "DELETE",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return 0, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return 0, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return 0, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return 0, err
    }

    var castedBody any
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return 0, err
    }
    return castedBody, nil
}
func (c *SidekoClient) DeleteWorkspace(request DeleteWorkspacesWorkspaceIdRequest) (DeleteWorkspacesWorkspaceIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/workspaces/"+anyToString(request.WorkspaceID))
    if err != nil {
        return DeleteWorkspacesWorkspaceIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return DeleteWorkspacesWorkspaceIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "DELETE",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return DeleteWorkspacesWorkspaceIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return DeleteWorkspacesWorkspaceIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return DeleteWorkspacesWorkspaceIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return DeleteWorkspacesWorkspaceIDResponse{}, err
    }

    var castedBody DeleteWorkspacesWorkspaceIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return DeleteWorkspacesWorkspaceIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetAllApis(request GetApisRequest) (GetApisResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/apis")
    if err != nil {
        return GetApisResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetApisResponse{}, err
	}

    queryParams := targetUrl.Query()
    queryParams.Set("workspace_id", anyToString(request.WorkspaceID))
    if request.CreatedBy != nil {
        queryParams.Set("created_by", anyToString(*request.CreatedBy))
    }
    if request.Cursor != nil {
        queryParams.Set("cursor", anyToString(*request.Cursor))
    }
    if request.Description != nil {
        queryParams.Set("description", anyToString(*request.Description))
    }
    if request.Limit != nil {
        queryParams.Set("limit", anyToString(*request.Limit))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetApisResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetApisResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetApisResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetApisResponse{}, err
    }

    var castedBody GetApisResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetApisResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetAnApi(request GetApisApiIdRequest) (any, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/apis/"+anyToString(request.APIID))
    if err != nil {
        return 0, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return 0, err
	}

    queryParams := targetUrl.Query()
    if request.Include != nil {
        queryParams.Set("include", anyToString(*request.Include))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return 0, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return 0, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return 0, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return 0, err
    }

    var castedBody any
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return 0, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetCollection(request GetApisApiIdCollectionsCollectionIdRequest) (GetApisAPIIDCollectionsCollectionIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/apis/"+anyToString(request.APIID)+"/collections/"+anyToString(request.CollectionID))
    if err != nil {
        return GetApisAPIIDCollectionsCollectionIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetApisAPIIDCollectionsCollectionIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.VersionID != nil {
        queryParams.Set("version_id", anyToString(*request.VersionID))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetApisAPIIDCollectionsCollectionIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetApisAPIIDCollectionsCollectionIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetApisAPIIDCollectionsCollectionIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetApisAPIIDCollectionsCollectionIDResponse{}, err
    }

    var castedBody GetApisAPIIDCollectionsCollectionIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetApisAPIIDCollectionsCollectionIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetSchema(request GetApisApiIdSchemasSchemaIdRequest) (any, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/apis/"+anyToString(request.APIID)+"/schemas/"+anyToString(request.SchemaID))
    if err != nil {
        return 0, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return 0, err
	}

    queryParams := targetUrl.Query()
    if request.Bundled != nil {
        queryParams.Set("bundled", anyToString(*request.Bundled))
    }
    if request.VersionID != nil {
        queryParams.Set("version_id", anyToString(*request.VersionID))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return 0, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return 0, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return 0, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return 0, err
    }

    var castedBody any
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return 0, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetSchemaFiles(request GetApisApiIdSchemasSchemaIdFilesRequest) (GetApisAPIIDSchemasSchemaIDFilesResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/apis/"+anyToString(request.APIID)+"/schemas/"+anyToString(request.SchemaID)+"/files")
    if err != nil {
        return GetApisAPIIDSchemasSchemaIDFilesResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetApisAPIIDSchemasSchemaIDFilesResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.Cursor != nil {
        queryParams.Set("cursor", anyToString(*request.Cursor))
    }
    if request.Limit != nil {
        queryParams.Set("limit", anyToString(*request.Limit))
    }
    if request.VersionID != nil {
        queryParams.Set("version_id", anyToString(*request.VersionID))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetApisAPIIDSchemasSchemaIDFilesResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetApisAPIIDSchemasSchemaIDFilesResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetApisAPIIDSchemasSchemaIDFilesResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetApisAPIIDSchemasSchemaIDFilesResponse{}, err
    }

    var castedBody GetApisAPIIDSchemasSchemaIDFilesResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetApisAPIIDSchemasSchemaIDFilesResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetSchemaFileContents(request GetApisApiIdSchemasSchemaIdFilesFilePathRequest) (GetApisAPIIDSchemasSchemaIDFilesFilePathResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/apis/"+anyToString(request.APIID)+"/schemas/"+anyToString(request.SchemaID)+"/files/"+anyToString(request.FilePath))
    if err != nil {
        return GetApisAPIIDSchemasSchemaIDFilesFilePathResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetApisAPIIDSchemasSchemaIDFilesFilePathResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.VersionID != nil {
        queryParams.Set("version_id", anyToString(*request.VersionID))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetApisAPIIDSchemasSchemaIDFilesFilePathResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetApisAPIIDSchemasSchemaIDFilesFilePathResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetApisAPIIDSchemasSchemaIDFilesFilePathResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetApisAPIIDSchemasSchemaIDFilesFilePathResponse{}, err
    }

    var castedBody GetApisAPIIDSchemasSchemaIDFilesFilePathResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetApisAPIIDSchemasSchemaIDFilesFilePathResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetApiTags(request GetApisApiIdTagsRequest) (GetApisAPIIDTagsResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/apis/"+anyToString(request.APIID)+"/tags")
    if err != nil {
        return GetApisAPIIDTagsResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetApisAPIIDTagsResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetApisAPIIDTagsResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetApisAPIIDTagsResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetApisAPIIDTagsResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetApisAPIIDTagsResponse{}, err
    }

    var castedBody GetApisAPIIDTagsResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetApisAPIIDTagsResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetStatusOfAnAsyncTask(request GetApisApiIdTasksTaskIdRequest) (GetApisAPIIDTasksTaskIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/apis/"+anyToString(request.APIID)+"/tasks/"+anyToString(request.TaskID))
    if err != nil {
        return GetApisAPIIDTasksTaskIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetApisAPIIDTasksTaskIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetApisAPIIDTasksTaskIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetApisAPIIDTasksTaskIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetApisAPIIDTasksTaskIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetApisAPIIDTasksTaskIDResponse{}, err
    }

    var castedBody GetApisAPIIDTasksTaskIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetApisAPIIDTasksTaskIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetAllVersions(request GetApisApiIdVersionsRequest) (GetApisAPIIDVersionsResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/apis/"+anyToString(request.APIID)+"/versions")
    if err != nil {
        return GetApisAPIIDVersionsResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetApisAPIIDVersionsResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.Cursor != nil {
        queryParams.Set("cursor", anyToString(*request.Cursor))
    }
    if request.Limit != nil {
        queryParams.Set("limit", anyToString(*request.Limit))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetApisAPIIDVersionsResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetApisAPIIDVersionsResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetApisAPIIDVersionsResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetApisAPIIDVersionsResponse{}, err
    }

    var castedBody GetApisAPIIDVersionsResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetApisAPIIDVersionsResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetApiVersion(request GetApisApiIdVersionsVersionIdRequest) (GetApisAPIIDVersionsVersionIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/apis/"+anyToString(request.APIID)+"/versions/"+anyToString(request.VersionID))
    if err != nil {
        return GetApisAPIIDVersionsVersionIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetApisAPIIDVersionsVersionIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetApisAPIIDVersionsVersionIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetApisAPIIDVersionsVersionIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetApisAPIIDVersionsVersionIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetApisAPIIDVersionsVersionIDResponse{}, err
    }

    var castedBody GetApisAPIIDVersionsVersionIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetApisAPIIDVersionsVersionIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetAuditLogs(request GetAuditLogsRequest) (GetAuditLogsResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/audit/logs")
    if err != nil {
        return GetAuditLogsResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetAuditLogsResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.Cursor != nil {
        queryParams.Set("cursor", anyToString(*request.Cursor))
    }
    if request.Limit != nil {
        queryParams.Set("limit", anyToString(*request.Limit))
    }
    if request.OrderBy != nil {
        queryParams.Set("order_by", anyToString(*request.OrderBy))
    }
    if request.Since != nil {
        queryParams.Set("since", anyToString(*request.Since))
    }
    if request.Until != nil {
        queryParams.Set("until", anyToString(*request.Until))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetAuditLogsResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetAuditLogsResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetAuditLogsResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetAuditLogsResponse{}, err
    }

    var castedBody GetAuditLogsResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetAuditLogsResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) AllCollections(request GetCollectionsRequest) (GetCollectionsResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/collections")
    if err != nil {
        return GetCollectionsResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetCollectionsResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.Name != nil {
        queryParams.Set("name", anyToString(*request.Name))
    }
    if request.WorkspaceID != nil {
        queryParams.Set("workspace_id", anyToString(*request.WorkspaceID))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetCollectionsResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetCollectionsResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetCollectionsResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetCollectionsResponse{}, err
    }

    var castedBody GetCollectionsResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetCollectionsResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) SingleCollection(request GetCollectionsCollectionIdRequest) (GetCollectionsCollectionIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/collections/"+anyToString(request.CollectionID))
    if err != nil {
        return GetCollectionsCollectionIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetCollectionsCollectionIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.AccessKey != nil {
        queryParams.Set("access_key", anyToString(*request.AccessKey))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetCollectionsCollectionIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetCollectionsCollectionIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetCollectionsCollectionIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetCollectionsCollectionIDResponse{}, err
    }

    var castedBody GetCollectionsCollectionIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetCollectionsCollectionIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetCollectionFolder(request GetCollectionsCollectionIdFoldersFolderIdRequest) (GetCollectionsCollectionIDFoldersFolderIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/collections/"+anyToString(request.CollectionID)+"/folders/"+anyToString(request.FolderID))
    if err != nil {
        return GetCollectionsCollectionIDFoldersFolderIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetCollectionsCollectionIDFoldersFolderIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.IDS != nil {
        queryParams.Set("ids", anyToString(*request.IDS))
    }
    if request.Populate != nil {
        queryParams.Set("populate", anyToString(*request.Populate))
    }
    if request.Uid != nil {
        queryParams.Set("uid", anyToString(*request.Uid))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetCollectionsCollectionIDFoldersFolderIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetCollectionsCollectionIDFoldersFolderIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetCollectionsCollectionIDFoldersFolderIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetCollectionsCollectionIDFoldersFolderIDResponse{}, err
    }

    var castedBody GetCollectionsCollectionIDFoldersFolderIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetCollectionsCollectionIDFoldersFolderIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetCollectionRequest(request GetCollectionsCollectionIdRequestsRequestIdRequest) (GetCollectionsCollectionIDRequestsRequestIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/collections/"+anyToString(request.CollectionID)+"/requests/"+anyToString(request.RequestID))
    if err != nil {
        return GetCollectionsCollectionIDRequestsRequestIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetCollectionsCollectionIDRequestsRequestIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.IDS != nil {
        queryParams.Set("ids", anyToString(*request.IDS))
    }
    if request.Populate != nil {
        queryParams.Set("populate", anyToString(*request.Populate))
    }
    if request.Uid != nil {
        queryParams.Set("uid", anyToString(*request.Uid))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetCollectionsCollectionIDRequestsRequestIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetCollectionsCollectionIDRequestsRequestIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetCollectionsCollectionIDRequestsRequestIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetCollectionsCollectionIDRequestsRequestIDResponse{}, err
    }

    var castedBody GetCollectionsCollectionIDRequestsRequestIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetCollectionsCollectionIDRequestsRequestIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetCollectionResponse(request GetCollectionsCollectionIdResponsesResponseIdRequest) (GetCollectionsCollectionIDResponsesResponseIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/collections/"+anyToString(request.CollectionID)+"/responses/"+anyToString(request.ResponseID))
    if err != nil {
        return GetCollectionsCollectionIDResponsesResponseIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetCollectionsCollectionIDResponsesResponseIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.IDS != nil {
        queryParams.Set("ids", anyToString(*request.IDS))
    }
    if request.Populate != nil {
        queryParams.Set("populate", anyToString(*request.Populate))
    }
    if request.Uid != nil {
        queryParams.Set("uid", anyToString(*request.Uid))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetCollectionsCollectionIDResponsesResponseIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetCollectionsCollectionIDResponsesResponseIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetCollectionsCollectionIDResponsesResponseIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetCollectionsCollectionIDResponsesResponseIDResponse{}, err
    }

    var castedBody GetCollectionsCollectionIDResponsesResponseIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetCollectionsCollectionIDResponsesResponseIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetCollectionTags(request GetCollectionsCollectionIdTagsRequest) (GetCollectionsCollectionIDTagsResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/collections/"+anyToString(request.CollectionID)+"/tags")
    if err != nil {
        return GetCollectionsCollectionIDTagsResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetCollectionsCollectionIDTagsResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetCollectionsCollectionIDTagsResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetCollectionsCollectionIDTagsResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetCollectionsCollectionIDTagsResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetCollectionsCollectionIDTagsResponse{}, err
    }

    var castedBody GetCollectionsCollectionIDTagsResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetCollectionsCollectionIDTagsResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) TransformCollectionToOpenApi(request GetCollectionsCollectionIdTransformationsRequest) (GetCollectionsCollectionIDTransformationsResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/collections/"+anyToString(request.CollectionID)+"/transformations")
    if err != nil {
        return GetCollectionsCollectionIDTransformationsResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetCollectionsCollectionIDTransformationsResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetCollectionsCollectionIDTransformationsResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetCollectionsCollectionIDTransformationsResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetCollectionsCollectionIDTransformationsResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetCollectionsCollectionIDTransformationsResponse{}, err
    }

    var castedBody GetCollectionsCollectionIDTransformationsResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetCollectionsCollectionIDTransformationsResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetDetectedSecretsLocations(request GetDetectedSecretsSecretIdLocationsRequest) (GetDetectedSecretsSecretIDLocationsResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/detected-secrets/"+anyToString(request.SecretID)+"/locations")
    if err != nil {
        return GetDetectedSecretsSecretIDLocationsResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetDetectedSecretsSecretIDLocationsResponse{}, err
	}

    queryParams := targetUrl.Query()
    queryParams.Set("workspace_id", anyToString(request.WorkspaceID))
    if request.Cursor != nil {
        queryParams.Set("cursor", anyToString(*request.Cursor))
    }
    if request.Limit != nil {
        queryParams.Set("limit", anyToString(*request.Limit))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetDetectedSecretsSecretIDLocationsResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetDetectedSecretsSecretIDLocationsResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetDetectedSecretsSecretIDLocationsResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetDetectedSecretsSecretIDLocationsResponse{}, err
    }

    var castedBody GetDetectedSecretsSecretIDLocationsResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetDetectedSecretsSecretIDLocationsResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) AllEnvironments(request GetEnvironmentsRequest) (GetEnvironmentsResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/environments")
    if err != nil {
        return GetEnvironmentsResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetEnvironmentsResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.WorkspaceID != nil {
        queryParams.Set("workspace_id", anyToString(*request.WorkspaceID))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetEnvironmentsResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetEnvironmentsResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetEnvironmentsResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetEnvironmentsResponse{}, err
    }

    var castedBody GetEnvironmentsResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetEnvironmentsResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) SingleEnvironment(request GetEnvironmentsEnvironmentIdRequest) (GetEnvironmentsEnvironmentIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/environments/"+anyToString(request.EnvironmentID))
    if err != nil {
        return GetEnvironmentsEnvironmentIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetEnvironmentsEnvironmentIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetEnvironmentsEnvironmentIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetEnvironmentsEnvironmentIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetEnvironmentsEnvironmentIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetEnvironmentsEnvironmentIDResponse{}, err
    }

    var castedBody GetEnvironmentsEnvironmentIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetEnvironmentsEnvironmentIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) ApiKeyOwner() (GetMeResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/me")
    if err != nil {
        return GetMeResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetMeResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetMeResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetMeResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetMeResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetMeResponse{}, err
    }

    var castedBody GetMeResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetMeResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetMocks(request GetMocksRequest) (GetMocksResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/mocks")
    if err != nil {
        return GetMocksResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetMocksResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.TeamID != nil {
        queryParams.Set("team_id", anyToString(*request.TeamID))
    }
    if request.Workspace != nil {
        queryParams.Set("workspace", anyToString(*request.Workspace))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetMocksResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetMocksResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetMocksResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetMocksResponse{}, err
    }

    var castedBody GetMocksResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetMocksResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetMock(request GetMocksMockIdRequest) (GetMocksMockIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/mocks/"+anyToString(request.MockID))
    if err != nil {
        return GetMocksMockIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetMocksMockIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetMocksMockIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetMocksMockIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetMocksMockIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetMocksMockIDResponse{}, err
    }

    var castedBody GetMocksMockIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetMocksMockIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetMockCallLogs(request GetMocksMockIdCallLogsRequest) (GetMocksMockIDCallLogsResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/mocks/"+anyToString(request.MockID)+"/call-logs")
    if err != nil {
        return GetMocksMockIDCallLogsResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetMocksMockIDCallLogsResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.Cursor != nil {
        queryParams.Set("cursor", anyToString(*request.Cursor))
    }
    if request.Direction != nil {
        queryParams.Set("direction", anyToString(*request.Direction))
    }
    if request.Include != nil {
        queryParams.Set("include", anyToString(*request.Include))
    }
    if request.Limit != nil {
        queryParams.Set("limit", anyToString(*request.Limit))
    }
    if request.RequestMethod != nil {
        queryParams.Set("request_method", anyToString(*request.RequestMethod))
    }
    if request.RequestPath != nil {
        queryParams.Set("request_path", anyToString(*request.RequestPath))
    }
    if request.ResponseStatusCode != nil {
        queryParams.Set("response_status_code", anyToString(*request.ResponseStatusCode))
    }
    if request.ResponseType != nil {
        queryParams.Set("response_type", anyToString(*request.ResponseType))
    }
    if request.Since != nil {
        queryParams.Set("since", anyToString(*request.Since))
    }
    if request.Sort != nil {
        queryParams.Set("sort", anyToString(*request.Sort))
    }
    if request.Until != nil {
        queryParams.Set("until", anyToString(*request.Until))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetMocksMockIDCallLogsResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetMocksMockIDCallLogsResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetMocksMockIDCallLogsResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetMocksMockIDCallLogsResponse{}, err
    }

    var castedBody GetMocksMockIDCallLogsResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetMocksMockIDCallLogsResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetMockServerResponses(request GetMocksMockIdServerResponsesRequest) ([]GetMocksMockIDServerResponsesResponseItem, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/mocks/"+anyToString(request.MockID)+"/server-responses")
    if err != nil {
        return []GetMocksMockIDServerResponsesResponseItem{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return []GetMocksMockIDServerResponsesResponseItem{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return []GetMocksMockIDServerResponsesResponseItem{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return []GetMocksMockIDServerResponsesResponseItem{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return []GetMocksMockIDServerResponsesResponseItem{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return []GetMocksMockIDServerResponsesResponseItem{}, err
    }

    var castedBody []GetMocksMockIDServerResponsesResponseItem
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return []GetMocksMockIDServerResponsesResponseItem{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetMockServerResponse(request GetMocksMockIdServerResponsesServerResponseIdRequest) ([]GetMocksMockIDServerResponsesServerResponseIDResponseItem, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/mocks/"+anyToString(request.MockID)+"/server-responses/"+anyToString(request.ServerResponseID))
    if err != nil {
        return []GetMocksMockIDServerResponsesServerResponseIDResponseItem{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return []GetMocksMockIDServerResponsesServerResponseIDResponseItem{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return []GetMocksMockIDServerResponsesServerResponseIDResponseItem{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return []GetMocksMockIDServerResponsesServerResponseIDResponseItem{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return []GetMocksMockIDServerResponsesServerResponseIDResponseItem{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return []GetMocksMockIDServerResponsesServerResponseIDResponseItem{}, err
    }

    var castedBody []GetMocksMockIDServerResponsesServerResponseIDResponseItem
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return []GetMocksMockIDServerResponsesServerResponseIDResponseItem{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) AllMonitors(request GetMonitorsRequest) (GetMonitorsResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/monitors")
    if err != nil {
        return GetMonitorsResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetMonitorsResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.Workspace != nil {
        queryParams.Set("workspace", anyToString(*request.Workspace))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetMonitorsResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetMonitorsResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetMonitorsResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetMonitorsResponse{}, err
    }

    var castedBody GetMonitorsResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetMonitorsResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) SingleMonitor(request GetMonitorsMonitorIdRequest) (GetMonitorsMonitorIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/monitors/"+anyToString(request.MonitorID))
    if err != nil {
        return GetMonitorsMonitorIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetMonitorsMonitorIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetMonitorsMonitorIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetMonitorsMonitorIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetMonitorsMonitorIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetMonitorsMonitorIDResponse{}, err
    }

    var castedBody GetMonitorsMonitorIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetMonitorsMonitorIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetAllElementsAndFolders(request GetNetworkPrivateRequest) (GetNetworkPrivateResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/network/private")
    if err != nil {
        return GetNetworkPrivateResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetNetworkPrivateResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.AddedBy != nil {
        queryParams.Set("added_by", anyToString(*request.AddedBy))
    }
    if request.CreatedBy != nil {
        queryParams.Set("created_by", anyToString(*request.CreatedBy))
    }
    if request.Description != nil {
        queryParams.Set("description", anyToString(*request.Description))
    }
    if request.Direction != nil {
        queryParams.Set("direction", anyToString(*request.Direction))
    }
    if request.Limit != nil {
        queryParams.Set("limit", anyToString(*request.Limit))
    }
    if request.Name != nil {
        queryParams.Set("name", anyToString(*request.Name))
    }
    if request.Offset != nil {
        queryParams.Set("offset", anyToString(*request.Offset))
    }
    if request.ParentFolderID != nil {
        queryParams.Set("parent_folder_id", anyToString(*request.ParentFolderID))
    }
    if request.Since != nil {
        queryParams.Set("since", anyToString(*request.Since))
    }
    if request.Sort != nil {
        queryParams.Set("sort", anyToString(*request.Sort))
    }
    if request.Summary != nil {
        queryParams.Set("summary", anyToString(*request.Summary))
    }
    if request.Type != nil {
        queryParams.Set("type", anyToString(*request.Type))
    }
    if request.Until != nil {
        queryParams.Set("until", anyToString(*request.Until))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetNetworkPrivateResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetNetworkPrivateResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetNetworkPrivateResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetNetworkPrivateResponse{}, err
    }

    var castedBody GetNetworkPrivateResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetNetworkPrivateResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetAllAddElementRequests(request GetNetworkPrivateNetworkEntityRequestAllRequest) (GetNetworkPrivateNetworkEntityRequestAllResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/network/private/network-entity/request/all")
    if err != nil {
        return GetNetworkPrivateNetworkEntityRequestAllResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetNetworkPrivateNetworkEntityRequestAllResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.Direction != nil {
        queryParams.Set("direction", anyToString(*request.Direction))
    }
    if request.Limit != nil {
        queryParams.Set("limit", anyToString(*request.Limit))
    }
    if request.Name != nil {
        queryParams.Set("name", anyToString(*request.Name))
    }
    if request.Offset != nil {
        queryParams.Set("offset", anyToString(*request.Offset))
    }
    if request.RequestedBy != nil {
        queryParams.Set("requested_by", anyToString(*request.RequestedBy))
    }
    if request.Since != nil {
        queryParams.Set("since", anyToString(*request.Since))
    }
    if request.Sort != nil {
        queryParams.Set("sort", anyToString(*request.Sort))
    }
    if request.Status != nil {
        queryParams.Set("status", anyToString(*request.Status))
    }
    if request.Type != nil {
        queryParams.Set("type", anyToString(*request.Type))
    }
    if request.Until != nil {
        queryParams.Set("until", anyToString(*request.Until))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetNetworkPrivateNetworkEntityRequestAllResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetNetworkPrivateNetworkEntityRequestAllResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetNetworkPrivateNetworkEntityRequestAllResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetNetworkPrivateNetworkEntityRequestAllResponse{}, err
    }

    var castedBody GetNetworkPrivateNetworkEntityRequestAllResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetNetworkPrivateNetworkEntityRequestAllResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) FetchAllGroupResources(request GetScimV2GroupsRequest) (GetScimV2GroupsResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/scim/v2/Groups")
    if err != nil {
        return GetScimV2GroupsResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetScimV2GroupsResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.Count != nil {
        queryParams.Set("count", anyToString(*request.Count))
    }
    if request.Filter != nil {
        queryParams.Set("filter", anyToString(*request.Filter))
    }
    if request.StartIndex != nil {
        queryParams.Set("start_index", anyToString(*request.StartIndex))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetScimV2GroupsResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetScimV2GroupsResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetScimV2GroupsResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetScimV2GroupsResponse{}, err
    }

    var castedBody GetScimV2GroupsResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetScimV2GroupsResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) FetchGroupResource(request GetScimV2GroupsGroupIdRequest) (GetScimV2GroupsGroupIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/scim/v2/Groups/"+anyToString(request.GroupID))
    if err != nil {
        return GetScimV2GroupsGroupIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetScimV2GroupsGroupIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetScimV2GroupsGroupIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetScimV2GroupsGroupIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetScimV2GroupsGroupIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetScimV2GroupsGroupIDResponse{}, err
    }

    var castedBody GetScimV2GroupsGroupIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetScimV2GroupsGroupIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetResourceTypes() ([]GetScimV2ResourceTypesResponseItem, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/scim/v2/ResourceTypes")
    if err != nil {
        return []GetScimV2ResourceTypesResponseItem{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return []GetScimV2ResourceTypesResponseItem{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return []GetScimV2ResourceTypesResponseItem{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return []GetScimV2ResourceTypesResponseItem{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return []GetScimV2ResourceTypesResponseItem{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return []GetScimV2ResourceTypesResponseItem{}, err
    }

    var castedBody []GetScimV2ResourceTypesResponseItem
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return []GetScimV2ResourceTypesResponseItem{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) ServiceProviderConfig() (GetScimV2ServiceProviderConfigResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/scim/v2/ServiceProviderConfig")
    if err != nil {
        return GetScimV2ServiceProviderConfigResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetScimV2ServiceProviderConfigResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetScimV2ServiceProviderConfigResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetScimV2ServiceProviderConfigResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetScimV2ServiceProviderConfigResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetScimV2ServiceProviderConfigResponse{}, err
    }

    var castedBody GetScimV2ServiceProviderConfigResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetScimV2ServiceProviderConfigResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) FetchAllUserResources(request GetScimV2UsersRequest) (GetScimV2UsersResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/scim/v2/Users")
    if err != nil {
        return GetScimV2UsersResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetScimV2UsersResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.Count != nil {
        queryParams.Set("count", anyToString(*request.Count))
    }
    if request.Filter != nil {
        queryParams.Set("filter", anyToString(*request.Filter))
    }
    if request.StartIndex != nil {
        queryParams.Set("start_index", anyToString(*request.StartIndex))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetScimV2UsersResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetScimV2UsersResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetScimV2UsersResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetScimV2UsersResponse{}, err
    }

    var castedBody GetScimV2UsersResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetScimV2UsersResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) FetchUserResource(request GetScimV2UsersUserIdRequest) (GetScimV2UsersUserIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/scim/v2/Users/"+anyToString(request.UserID))
    if err != nil {
        return GetScimV2UsersUserIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetScimV2UsersUserIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetScimV2UsersUserIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetScimV2UsersUserIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetScimV2UsersUserIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetScimV2UsersUserIDResponse{}, err
    }

    var castedBody GetScimV2UsersUserIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetScimV2UsersUserIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetSecretTypes() (GetSecretTypesResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/secret-types")
    if err != nil {
        return GetSecretTypesResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetSecretTypesResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetSecretTypesResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetSecretTypesResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetSecretTypesResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetSecretTypesResponse{}, err
    }

    var castedBody GetSecretTypesResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetSecretTypesResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetTaggedEntities(request GetTagsSlugEntitiesRequest) (GetTagsSlugEntitiesResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/tags/"+anyToString(request.Slug)+"/entities")
    if err != nil {
        return GetTagsSlugEntitiesResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetTagsSlugEntitiesResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.Cursor != nil {
        queryParams.Set("cursor", anyToString(*request.Cursor))
    }
    if request.Direction != nil {
        queryParams.Set("direction", anyToString(*request.Direction))
    }
    if request.EntityType != nil {
        queryParams.Set("entity_type", anyToString(*request.EntityType))
    }
    if request.Limit != nil {
        queryParams.Set("limit", anyToString(*request.Limit))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetTagsSlugEntitiesResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetTagsSlugEntitiesResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetTagsSlugEntitiesResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetTagsSlugEntitiesResponse{}, err
    }

    var castedBody GetTagsSlugEntitiesResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetTagsSlugEntitiesResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) AllWorkspaces(request GetWorkspacesRequest) (GetWorkspacesResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/workspaces")
    if err != nil {
        return GetWorkspacesResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetWorkspacesResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.Type != nil {
        queryParams.Set("type", anyToString(*request.Type))
    }
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetWorkspacesResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetWorkspacesResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetWorkspacesResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetWorkspacesResponse{}, err
    }

    var castedBody GetWorkspacesResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetWorkspacesResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) SingleWorkspace(request GetWorkspacesWorkspaceIdRequest) (GetWorkspacesWorkspaceIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/workspaces/"+anyToString(request.WorkspaceID))
    if err != nil {
        return GetWorkspacesWorkspaceIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetWorkspacesWorkspaceIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetWorkspacesWorkspaceIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetWorkspacesWorkspaceIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetWorkspacesWorkspaceIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetWorkspacesWorkspaceIDResponse{}, err
    }

    var castedBody GetWorkspacesWorkspaceIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetWorkspacesWorkspaceIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetWorkspaceGlobalVariables(request GetWorkspacesWorkspaceIdGlobalVariablesRequest) (GetWorkspacesWorkspaceIDGlobalVariablesResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/workspaces/"+anyToString(request.WorkspaceID)+"/global-variables")
    if err != nil {
        return GetWorkspacesWorkspaceIDGlobalVariablesResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetWorkspacesWorkspaceIDGlobalVariablesResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetWorkspacesWorkspaceIDGlobalVariablesResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetWorkspacesWorkspaceIDGlobalVariablesResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetWorkspacesWorkspaceIDGlobalVariablesResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetWorkspacesWorkspaceIDGlobalVariablesResponse{}, err
    }

    var castedBody GetWorkspacesWorkspaceIDGlobalVariablesResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetWorkspacesWorkspaceIDGlobalVariablesResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) GetWorkspaceTags(request GetWorkspacesWorkspaceIdTagsRequest) (GetWorkspacesWorkspaceIDTagsResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/workspaces/"+anyToString(request.WorkspaceID)+"/tags")
    if err != nil {
        return GetWorkspacesWorkspaceIDTagsResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetWorkspacesWorkspaceIDTagsResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "GET",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return GetWorkspacesWorkspaceIDTagsResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return GetWorkspacesWorkspaceIDTagsResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return GetWorkspacesWorkspaceIDTagsResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return GetWorkspacesWorkspaceIDTagsResponse{}, err
    }

    var castedBody GetWorkspacesWorkspaceIDTagsResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return GetWorkspacesWorkspaceIDTagsResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) PatchCollection(request PatchCollectionsCollectionIdRequest) (PatchCollectionsCollectionIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/collections/"+anyToString(request.CollectionID))
    if err != nil {
        return PatchCollectionsCollectionIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PatchCollectionsCollectionIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PatchCollectionsCollectionIDResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "PATCH",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PatchCollectionsCollectionIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PatchCollectionsCollectionIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PatchCollectionsCollectionIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PatchCollectionsCollectionIDResponse{}, err
    }

    var castedBody PatchCollectionsCollectionIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PatchCollectionsCollectionIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) PatchScimV2GroupsGroupId(request PatchScimV2GroupsGroupIdRequest) (PatchScimV2GroupsGroupIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/scim/v2/Groups/"+anyToString(request.GroupID))
    if err != nil {
        return PatchScimV2GroupsGroupIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PatchScimV2GroupsGroupIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PatchScimV2GroupsGroupIDResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "PATCH",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PatchScimV2GroupsGroupIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PatchScimV2GroupsGroupIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PatchScimV2GroupsGroupIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PatchScimV2GroupsGroupIDResponse{}, err
    }

    var castedBody PatchScimV2GroupsGroupIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PatchScimV2GroupsGroupIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) UpdateUserState(request PatchScimV2UsersUserIdRequest) (PatchScimV2UsersUserIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/scim/v2/Users/"+anyToString(request.UserID))
    if err != nil {
        return PatchScimV2UsersUserIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PatchScimV2UsersUserIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PatchScimV2UsersUserIDResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "PATCH",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PatchScimV2UsersUserIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PatchScimV2UsersUserIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PatchScimV2UsersUserIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PatchScimV2UsersUserIDResponse{}, err
    }

    var castedBody PatchScimV2UsersUserIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PatchScimV2UsersUserIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) CreateApi(request PostApisRequest) (PostApisResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/apis")
    if err != nil {
        return PostApisResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PostApisResponse{}, err
	}

    queryParams := targetUrl.Query()
    queryParams.Set("workspace_id", anyToString(request.WorkspaceID))
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PostApisResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PostApisResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PostApisResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PostApisResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PostApisResponse{}, err
    }

    var castedBody PostApisResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PostApisResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) AddCollection(request PostApisApiIdCollectionsRequest) (PostApisAPIIDCollectionsResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/apis/"+anyToString(request.APIID)+"/collections")
    if err != nil {
        return PostApisAPIIDCollectionsResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PostApisAPIIDCollectionsResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PostApisAPIIDCollectionsResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PostApisAPIIDCollectionsResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PostApisAPIIDCollectionsResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PostApisAPIIDCollectionsResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PostApisAPIIDCollectionsResponse{}, err
    }

    var castedBody PostApisAPIIDCollectionsResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PostApisAPIIDCollectionsResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) CreateApiSchema(request PostApisApiIdSchemasRequest) (PostApisAPIIDSchemasResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/apis/"+anyToString(request.APIID)+"/schemas")
    if err != nil {
        return PostApisAPIIDSchemasResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PostApisAPIIDSchemasResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PostApisAPIIDSchemasResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PostApisAPIIDSchemasResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PostApisAPIIDSchemasResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PostApisAPIIDSchemasResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PostApisAPIIDSchemasResponse{}, err
    }

    var castedBody PostApisAPIIDSchemasResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PostApisAPIIDSchemasResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) CreateApiVersion(request PostApisApiIdVersionsRequest) (PostApisAPIIDVersionsResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/apis/"+anyToString(request.APIID)+"/versions")
    if err != nil {
        return PostApisAPIIDVersionsResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PostApisAPIIDVersionsResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PostApisAPIIDVersionsResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PostApisAPIIDVersionsResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PostApisAPIIDVersionsResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PostApisAPIIDVersionsResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PostApisAPIIDVersionsResponse{}, err
    }

    var castedBody PostApisAPIIDVersionsResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PostApisAPIIDVersionsResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) CreateCollection(request PostCollectionsRequest) (PostCollectionsResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/collections")
    if err != nil {
        return PostCollectionsResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PostCollectionsResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.WorkspaceID != nil {
        queryParams.Set("workspace_id", anyToString(*request.WorkspaceID))
    }
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PostCollectionsResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PostCollectionsResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PostCollectionsResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PostCollectionsResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PostCollectionsResponse{}, err
    }

    var castedBody PostCollectionsResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PostCollectionsResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) CreateAFork(request PostCollectionsForkCollectionIdRequest) (PostCollectionsForkCollectionIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/collections/fork/"+anyToString(request.CollectionID))
    if err != nil {
        return PostCollectionsForkCollectionIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PostCollectionsForkCollectionIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    queryParams.Set("workspace", anyToString(request.Workspace))
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PostCollectionsForkCollectionIDResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PostCollectionsForkCollectionIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PostCollectionsForkCollectionIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PostCollectionsForkCollectionIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PostCollectionsForkCollectionIDResponse{}, err
    }

    var castedBody PostCollectionsForkCollectionIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PostCollectionsForkCollectionIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) MergeAFork(request PostCollectionsMergeRequest) (PostCollectionsMergeResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/collections/merge")
    if err != nil {
        return PostCollectionsMergeResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PostCollectionsMergeResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PostCollectionsMergeResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PostCollectionsMergeResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PostCollectionsMergeResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PostCollectionsMergeResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PostCollectionsMergeResponse{}, err
    }

    var castedBody PostCollectionsMergeResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PostCollectionsMergeResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) CreateCollectionFolder(request PostCollectionsCollectionIdFoldersRequest) (PostCollectionsCollectionIDFoldersResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/collections/"+anyToString(request.CollectionID)+"/folders")
    if err != nil {
        return PostCollectionsCollectionIDFoldersResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PostCollectionsCollectionIDFoldersResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PostCollectionsCollectionIDFoldersResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PostCollectionsCollectionIDFoldersResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PostCollectionsCollectionIDFoldersResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PostCollectionsCollectionIDFoldersResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PostCollectionsCollectionIDFoldersResponse{}, err
    }

    var castedBody PostCollectionsCollectionIDFoldersResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PostCollectionsCollectionIDFoldersResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) CreateCollectionRequest(request PostCollectionsCollectionIdRequestsRequest) (PostCollectionsCollectionIDRequestsResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/collections/"+anyToString(request.CollectionID)+"/requests")
    if err != nil {
        return PostCollectionsCollectionIDRequestsResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PostCollectionsCollectionIDRequestsResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.FolderID != nil {
        queryParams.Set("folder_id", anyToString(*request.FolderID))
    }
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PostCollectionsCollectionIDRequestsResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PostCollectionsCollectionIDRequestsResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PostCollectionsCollectionIDRequestsResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PostCollectionsCollectionIDRequestsResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PostCollectionsCollectionIDRequestsResponse{}, err
    }

    var castedBody PostCollectionsCollectionIDRequestsResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PostCollectionsCollectionIDRequestsResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) CreateCollectionResponse(request PostCollectionsCollectionIdResponsesRequest) (PostCollectionsCollectionIDResponsesResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/collections/"+anyToString(request.CollectionID)+"/responses")
    if err != nil {
        return PostCollectionsCollectionIDResponsesResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PostCollectionsCollectionIDResponsesResponse{}, err
	}

    queryParams := targetUrl.Query()
    queryParams.Set("request_id", anyToString(request.RequestID))
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PostCollectionsCollectionIDResponsesResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PostCollectionsCollectionIDResponsesResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PostCollectionsCollectionIDResponsesResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PostCollectionsCollectionIDResponsesResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PostCollectionsCollectionIDResponsesResponse{}, err
    }

    var castedBody PostCollectionsCollectionIDResponsesResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PostCollectionsCollectionIDResponsesResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) DetectedSecretsQueries(request PostDetectedSecretsQueriesRequest) (PostDetectedSecretsQueriesResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/detected-secrets-queries")
    if err != nil {
        return PostDetectedSecretsQueriesResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PostDetectedSecretsQueriesResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.Cursor != nil {
        queryParams.Set("cursor", anyToString(*request.Cursor))
    }
    if request.Include != nil {
        queryParams.Set("include", anyToString(*request.Include))
    }
    if request.Limit != nil {
        queryParams.Set("limit", anyToString(*request.Limit))
    }
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PostDetectedSecretsQueriesResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PostDetectedSecretsQueriesResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PostDetectedSecretsQueriesResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PostDetectedSecretsQueriesResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PostDetectedSecretsQueriesResponse{}, err
    }

    var castedBody PostDetectedSecretsQueriesResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PostDetectedSecretsQueriesResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) CreateEnvironment(request PostEnvironmentsRequest) (PostEnvironmentsResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/environments")
    if err != nil {
        return PostEnvironmentsResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PostEnvironmentsResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.WorkspaceID != nil {
        queryParams.Set("workspace_id", anyToString(*request.WorkspaceID))
    }
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PostEnvironmentsResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PostEnvironmentsResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PostEnvironmentsResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PostEnvironmentsResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PostEnvironmentsResponse{}, err
    }

    var castedBody PostEnvironmentsResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PostEnvironmentsResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) ImportExternalApiSpecification(request PostImportOpenapiRequest) (PostImportOpenapiResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/import/openapi")
    if err != nil {
        return PostImportOpenapiResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PostImportOpenapiResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.WorkspaceID != nil {
        queryParams.Set("workspace_id", anyToString(*request.WorkspaceID))
    }
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PostImportOpenapiResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PostImportOpenapiResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PostImportOpenapiResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PostImportOpenapiResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PostImportOpenapiResponse{}, err
    }

    var castedBody PostImportOpenapiResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PostImportOpenapiResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) CreateMock(request PostMocksRequest) (PostMocksResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/mocks")
    if err != nil {
        return PostMocksResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PostMocksResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.WorkspaceID != nil {
        queryParams.Set("workspace_id", anyToString(*request.WorkspaceID))
    }
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PostMocksResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PostMocksResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PostMocksResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PostMocksResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PostMocksResponse{}, err
    }

    var castedBody PostMocksResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PostMocksResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) PublishMock(request PostMocksMockIdPublishRequest) (PostMocksMockIDPublishResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/mocks/"+anyToString(request.MockID)+"/publish")
    if err != nil {
        return PostMocksMockIDPublishResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PostMocksMockIDPublishResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return PostMocksMockIDPublishResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PostMocksMockIDPublishResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PostMocksMockIDPublishResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PostMocksMockIDPublishResponse{}, err
    }

    var castedBody PostMocksMockIDPublishResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PostMocksMockIDPublishResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) CreateServerResponse(request PostMocksMockIdServerResponsesRequest) ([]PostMocksMockIDServerResponsesResponseItem, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/mocks/"+anyToString(request.MockID)+"/server-responses")
    if err != nil {
        return []PostMocksMockIDServerResponsesResponseItem{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return []PostMocksMockIDServerResponsesResponseItem{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return []PostMocksMockIDServerResponsesResponseItem{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return []PostMocksMockIDServerResponsesResponseItem{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return []PostMocksMockIDServerResponsesResponseItem{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return []PostMocksMockIDServerResponsesResponseItem{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return []PostMocksMockIDServerResponsesResponseItem{}, err
    }

    var castedBody []PostMocksMockIDServerResponsesResponseItem
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return []PostMocksMockIDServerResponsesResponseItem{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) CreateMonitor(request PostMonitorsRequest) (PostMonitorsResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/monitors")
    if err != nil {
        return PostMonitorsResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PostMonitorsResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.WorkspaceID != nil {
        queryParams.Set("workspace_id", anyToString(*request.WorkspaceID))
    }
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PostMonitorsResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PostMonitorsResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PostMonitorsResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PostMonitorsResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PostMonitorsResponse{}, err
    }

    var castedBody PostMonitorsResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PostMonitorsResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) RunAMonitor(request PostMonitorsMonitorIdRunRequest) (PostMonitorsMonitorIDRunResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/monitors/"+anyToString(request.MonitorID)+"/run")
    if err != nil {
        return PostMonitorsMonitorIDRunResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PostMonitorsMonitorIDRunResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return PostMonitorsMonitorIDRunResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PostMonitorsMonitorIDRunResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PostMonitorsMonitorIDRunResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PostMonitorsMonitorIDRunResponse{}, err
    }

    var castedBody PostMonitorsMonitorIDRunResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PostMonitorsMonitorIDRunResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) PostElementOrFolder(request PostNetworkPrivateRequest) (any, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/network/private")
    if err != nil {
        return 0, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return 0, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return 0, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return 0, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return 0, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return 0, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return 0, err
    }

    var castedBody any
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return 0, err
    }
    return castedBody, nil
}
func (c *SidekoClient) CreateGroup(request PostScimV2GroupsRequest) (PostScimV2GroupsResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/scim/v2/Groups")
    if err != nil {
        return PostScimV2GroupsResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PostScimV2GroupsResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PostScimV2GroupsResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PostScimV2GroupsResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PostScimV2GroupsResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PostScimV2GroupsResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PostScimV2GroupsResponse{}, err
    }

    var castedBody PostScimV2GroupsResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PostScimV2GroupsResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) CreateUser(request PostScimV2UsersRequest) (PostScimV2UsersResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/scim/v2/Users")
    if err != nil {
        return PostScimV2UsersResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PostScimV2UsersResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PostScimV2UsersResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PostScimV2UsersResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PostScimV2UsersResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PostScimV2UsersResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PostScimV2UsersResponse{}, err
    }

    var castedBody PostScimV2UsersResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PostScimV2UsersResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) SchemaSecurityValidation(request PostSecurityApiValidationRequest) (PostSecurityAPIValidationResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/security/api-validation")
    if err != nil {
        return PostSecurityAPIValidationResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PostSecurityAPIValidationResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PostSecurityAPIValidationResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PostSecurityAPIValidationResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PostSecurityAPIValidationResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PostSecurityAPIValidationResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PostSecurityAPIValidationResponse{}, err
    }

    var castedBody PostSecurityAPIValidationResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PostSecurityAPIValidationResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) CreateWebhook(request PostWebhooksRequest) (PostWebhooksResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/webhooks")
    if err != nil {
        return PostWebhooksResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PostWebhooksResponse{}, err
	}

    queryParams := targetUrl.Query()
    if request.WorkspaceID != nil {
        queryParams.Set("workspace_id", anyToString(*request.WorkspaceID))
    }
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PostWebhooksResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PostWebhooksResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PostWebhooksResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PostWebhooksResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PostWebhooksResponse{}, err
    }

    var castedBody PostWebhooksResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PostWebhooksResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) CreateWorkspace(request PostWorkspacesRequest) (PostWorkspacesResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/workspaces")
    if err != nil {
        return PostWorkspacesResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PostWorkspacesResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PostWorkspacesResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "POST",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PostWorkspacesResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PostWorkspacesResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PostWorkspacesResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PostWorkspacesResponse{}, err
    }

    var castedBody PostWorkspacesResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PostWorkspacesResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) UpdateAnApi(request PutApisApiIdRequest) (PutApisAPIIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/apis/"+anyToString(request.APIID))
    if err != nil {
        return PutApisAPIIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PutApisAPIIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PutApisAPIIDResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "PUT",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PutApisAPIIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PutApisAPIIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PutApisAPIIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PutApisAPIIDResponse{}, err
    }

    var castedBody PutApisAPIIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PutApisAPIIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) SyncCollectionWithSchema(request PutApisApiIdCollectionsCollectionIdSyncWithSchemaTasksRequest) (PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/apis/"+anyToString(request.APIID)+"/collections/"+anyToString(request.CollectionID)+"/sync-with-schema-tasks")
    if err != nil {
        return PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()


    req, err := http.NewRequest(
        "PUT",
        targetUrl.String(),
        nil,
    )
    if err != nil {
        return PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse{}, err
    }

    var castedBody PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) CreateOrUpdateSchemaFile(request PutApisApiIdSchemasSchemaIdFilesFilePathRequest) (PutApisAPIIDSchemasSchemaIDFilesFilePathResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/apis/"+anyToString(request.APIID)+"/schemas/"+anyToString(request.SchemaID)+"/files/"+anyToString(request.FilePath))
    if err != nil {
        return PutApisAPIIDSchemasSchemaIDFilesFilePathResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PutApisAPIIDSchemasSchemaIDFilesFilePathResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PutApisAPIIDSchemasSchemaIDFilesFilePathResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "PUT",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PutApisAPIIDSchemasSchemaIDFilesFilePathResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PutApisAPIIDSchemasSchemaIDFilesFilePathResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PutApisAPIIDSchemasSchemaIDFilesFilePathResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PutApisAPIIDSchemasSchemaIDFilesFilePathResponse{}, err
    }

    var castedBody PutApisAPIIDSchemasSchemaIDFilesFilePathResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PutApisAPIIDSchemasSchemaIDFilesFilePathResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) UpdateApiTags(request PutApisApiIdTagsRequest) (PutApisAPIIDTagsResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/apis/"+anyToString(request.APIID)+"/tags")
    if err != nil {
        return PutApisAPIIDTagsResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PutApisAPIIDTagsResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PutApisAPIIDTagsResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "PUT",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PutApisAPIIDTagsResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PutApisAPIIDTagsResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PutApisAPIIDTagsResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PutApisAPIIDTagsResponse{}, err
    }

    var castedBody PutApisAPIIDTagsResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PutApisAPIIDTagsResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) UpdateApiVersion(request PutApisApiIdVersionsVersionIdRequest) (PutApisAPIIDVersionsVersionIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/apis/"+anyToString(request.APIID)+"/versions/"+anyToString(request.VersionID))
    if err != nil {
        return PutApisAPIIDVersionsVersionIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PutApisAPIIDVersionsVersionIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PutApisAPIIDVersionsVersionIDResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "PUT",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PutApisAPIIDVersionsVersionIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PutApisAPIIDVersionsVersionIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PutApisAPIIDVersionsVersionIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PutApisAPIIDVersionsVersionIDResponse{}, err
    }

    var castedBody PutApisAPIIDVersionsVersionIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PutApisAPIIDVersionsVersionIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) PutCollection(request PutCollectionsCollectionIdRequest) (PutCollectionsCollectionIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/collections/"+anyToString(request.CollectionID))
    if err != nil {
        return PutCollectionsCollectionIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PutCollectionsCollectionIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PutCollectionsCollectionIDResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "PUT",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PutCollectionsCollectionIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PutCollectionsCollectionIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PutCollectionsCollectionIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PutCollectionsCollectionIDResponse{}, err
    }

    var castedBody PutCollectionsCollectionIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PutCollectionsCollectionIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) UpdateCollectionFolder(request PutCollectionsCollectionIdFoldersFolderIdRequest) (PutCollectionsCollectionIDFoldersFolderIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/collections/"+anyToString(request.CollectionID)+"/folders/"+anyToString(request.FolderID))
    if err != nil {
        return PutCollectionsCollectionIDFoldersFolderIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PutCollectionsCollectionIDFoldersFolderIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PutCollectionsCollectionIDFoldersFolderIDResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "PUT",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PutCollectionsCollectionIDFoldersFolderIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PutCollectionsCollectionIDFoldersFolderIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PutCollectionsCollectionIDFoldersFolderIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PutCollectionsCollectionIDFoldersFolderIDResponse{}, err
    }

    var castedBody PutCollectionsCollectionIDFoldersFolderIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PutCollectionsCollectionIDFoldersFolderIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) UpdateCollectionRequest(request PutCollectionsCollectionIdRequestsRequestIdRequest) (PutCollectionsCollectionIDRequestsRequestIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/collections/"+anyToString(request.CollectionID)+"/requests/"+anyToString(request.RequestID))
    if err != nil {
        return PutCollectionsCollectionIDRequestsRequestIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PutCollectionsCollectionIDRequestsRequestIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PutCollectionsCollectionIDRequestsRequestIDResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "PUT",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PutCollectionsCollectionIDRequestsRequestIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PutCollectionsCollectionIDRequestsRequestIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PutCollectionsCollectionIDRequestsRequestIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PutCollectionsCollectionIDRequestsRequestIDResponse{}, err
    }

    var castedBody PutCollectionsCollectionIDRequestsRequestIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PutCollectionsCollectionIDRequestsRequestIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) UpdateCollectionResponse(request PutCollectionsCollectionIdResponsesResponseIdRequest) (PutCollectionsCollectionIDResponsesResponseIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/collections/"+anyToString(request.CollectionID)+"/responses/"+anyToString(request.ResponseID))
    if err != nil {
        return PutCollectionsCollectionIDResponsesResponseIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PutCollectionsCollectionIDResponsesResponseIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PutCollectionsCollectionIDResponsesResponseIDResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "PUT",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PutCollectionsCollectionIDResponsesResponseIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PutCollectionsCollectionIDResponsesResponseIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PutCollectionsCollectionIDResponsesResponseIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PutCollectionsCollectionIDResponsesResponseIDResponse{}, err
    }

    var castedBody PutCollectionsCollectionIDResponsesResponseIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PutCollectionsCollectionIDResponsesResponseIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) UpdateCollectionTags(request PutCollectionsCollectionIdTagsRequest) (PutCollectionsCollectionIDTagsResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/collections/"+anyToString(request.CollectionID)+"/tags")
    if err != nil {
        return PutCollectionsCollectionIDTagsResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PutCollectionsCollectionIDTagsResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PutCollectionsCollectionIDTagsResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "PUT",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PutCollectionsCollectionIDTagsResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PutCollectionsCollectionIDTagsResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PutCollectionsCollectionIDTagsResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PutCollectionsCollectionIDTagsResponse{}, err
    }

    var castedBody PutCollectionsCollectionIDTagsResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PutCollectionsCollectionIDTagsResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) UpdateDetectedSecretResolutions(request PutDetectedSecretsSecretIdRequest) (PutDetectedSecretsSecretIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/detected-secrets/"+anyToString(request.SecretID))
    if err != nil {
        return PutDetectedSecretsSecretIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PutDetectedSecretsSecretIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PutDetectedSecretsSecretIDResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "PUT",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PutDetectedSecretsSecretIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PutDetectedSecretsSecretIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PutDetectedSecretsSecretIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PutDetectedSecretsSecretIDResponse{}, err
    }

    var castedBody PutDetectedSecretsSecretIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PutDetectedSecretsSecretIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) UpdateEnvironment(request PutEnvironmentsEnvironmentIdRequest) (PutEnvironmentsEnvironmentIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/environments/"+anyToString(request.EnvironmentID))
    if err != nil {
        return PutEnvironmentsEnvironmentIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PutEnvironmentsEnvironmentIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PutEnvironmentsEnvironmentIDResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "PUT",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PutEnvironmentsEnvironmentIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PutEnvironmentsEnvironmentIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PutEnvironmentsEnvironmentIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PutEnvironmentsEnvironmentIDResponse{}, err
    }

    var castedBody PutEnvironmentsEnvironmentIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PutEnvironmentsEnvironmentIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) UpdateMock(request PutMocksMockIdRequest) (PutMocksMockIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/mocks/"+anyToString(request.MockID))
    if err != nil {
        return PutMocksMockIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PutMocksMockIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PutMocksMockIDResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "PUT",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PutMocksMockIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PutMocksMockIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PutMocksMockIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PutMocksMockIDResponse{}, err
    }

    var castedBody PutMocksMockIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PutMocksMockIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) UpdateServerResponse(request PutMocksMockIdServerResponsesServerResponseIdRequest) ([]PutMocksMockIDServerResponsesServerResponseIDResponseItem, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/mocks/"+anyToString(request.MockID)+"/server-responses/"+anyToString(request.ServerResponseID))
    if err != nil {
        return []PutMocksMockIDServerResponsesServerResponseIDResponseItem{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return []PutMocksMockIDServerResponsesServerResponseIDResponseItem{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return []PutMocksMockIDServerResponsesServerResponseIDResponseItem{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "PUT",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return []PutMocksMockIDServerResponsesServerResponseIDResponseItem{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return []PutMocksMockIDServerResponsesServerResponseIDResponseItem{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return []PutMocksMockIDServerResponsesServerResponseIDResponseItem{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return []PutMocksMockIDServerResponsesServerResponseIDResponseItem{}, err
    }

    var castedBody []PutMocksMockIDServerResponsesServerResponseIDResponseItem
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return []PutMocksMockIDServerResponsesServerResponseIDResponseItem{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) UpdateMonitor(request PutMonitorsMonitorIdRequest) (PutMonitorsMonitorIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/monitors/"+anyToString(request.MonitorID))
    if err != nil {
        return PutMonitorsMonitorIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PutMonitorsMonitorIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PutMonitorsMonitorIDResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "PUT",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PutMonitorsMonitorIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PutMonitorsMonitorIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PutMonitorsMonitorIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PutMonitorsMonitorIDResponse{}, err
    }

    var castedBody PutMonitorsMonitorIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PutMonitorsMonitorIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) RespondElementAddRequest(request PutNetworkPrivateNetworkEntityRequestRequestIdRequest) (PutNetworkPrivateNetworkEntityRequestRequestIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/network/private/network-entity/request/"+anyToString(request.RequestID))
    if err != nil {
        return PutNetworkPrivateNetworkEntityRequestRequestIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PutNetworkPrivateNetworkEntityRequestRequestIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PutNetworkPrivateNetworkEntityRequestRequestIDResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "PUT",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PutNetworkPrivateNetworkEntityRequestRequestIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PutNetworkPrivateNetworkEntityRequestRequestIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PutNetworkPrivateNetworkEntityRequestRequestIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PutNetworkPrivateNetworkEntityRequestRequestIDResponse{}, err
    }

    var castedBody PutNetworkPrivateNetworkEntityRequestRequestIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PutNetworkPrivateNetworkEntityRequestRequestIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) PutElementOrFolder(request PutNetworkPrivateElementTypeElementIdRequest) (any, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/network/private/"+anyToString(request.ElementType)+"/"+anyToString(request.ElementID))
    if err != nil {
        return 0, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return 0, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return 0, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "PUT",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return 0, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return 0, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return 0, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return 0, err
    }

    var castedBody any
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return 0, err
    }
    return castedBody, nil
}
func (c *SidekoClient) UpdateUserInformation(request PutScimV2UsersUserIdRequest) (PutScimV2UsersUserIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/scim/v2/Users/"+anyToString(request.UserID))
    if err != nil {
        return PutScimV2UsersUserIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PutScimV2UsersUserIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PutScimV2UsersUserIDResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "PUT",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PutScimV2UsersUserIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PutScimV2UsersUserIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PutScimV2UsersUserIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PutScimV2UsersUserIDResponse{}, err
    }

    var castedBody PutScimV2UsersUserIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PutScimV2UsersUserIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) UpdateWorkspace(request PutWorkspacesWorkspaceIdRequest) (PutWorkspacesWorkspaceIDResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/workspaces/"+anyToString(request.WorkspaceID))
    if err != nil {
        return PutWorkspacesWorkspaceIDResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PutWorkspacesWorkspaceIDResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PutWorkspacesWorkspaceIDResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "PUT",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PutWorkspacesWorkspaceIDResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PutWorkspacesWorkspaceIDResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PutWorkspacesWorkspaceIDResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PutWorkspacesWorkspaceIDResponse{}, err
    }

    var castedBody PutWorkspacesWorkspaceIDResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PutWorkspacesWorkspaceIDResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) PutWorkspaceGlobalVariables(request PutWorkspacesWorkspaceIdGlobalVariablesRequest) (PutWorkspacesWorkspaceIDGlobalVariablesResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/workspaces/"+anyToString(request.WorkspaceID)+"/global-variables")
    if err != nil {
        return PutWorkspacesWorkspaceIDGlobalVariablesResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PutWorkspacesWorkspaceIDGlobalVariablesResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PutWorkspacesWorkspaceIDGlobalVariablesResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "PUT",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PutWorkspacesWorkspaceIDGlobalVariablesResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PutWorkspacesWorkspaceIDGlobalVariablesResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PutWorkspacesWorkspaceIDGlobalVariablesResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PutWorkspacesWorkspaceIDGlobalVariablesResponse{}, err
    }

    var castedBody PutWorkspacesWorkspaceIDGlobalVariablesResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PutWorkspacesWorkspaceIDGlobalVariablesResponse{}, err
    }
    return castedBody, nil
}
func (c *SidekoClient) UpdateWorkspaceTags(request PutWorkspacesWorkspaceIdTagsRequest) (PutWorkspacesWorkspaceIDTagsResponse, error) {
    rawUrl, err := url.JoinPath(c.baseUrl, "/workspaces/"+anyToString(request.WorkspaceID)+"/tags")
    if err != nil {
        return PutWorkspacesWorkspaceIDTagsResponse{}, err
    }

    targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return PutWorkspacesWorkspaceIDTagsResponse{}, err
	}

    queryParams := targetUrl.Query()
    targetUrl.RawQuery = queryParams.Encode()

	requestBodyBytes, err := json.Marshal(request.Data)
    if err != nil {
        return PutWorkspacesWorkspaceIDTagsResponse{}, err
    }
    requestBodyBuff := bytes.NewBuffer(requestBodyBytes)

    req, err := http.NewRequest(
        "PUT",
        targetUrl.String(),
        requestBodyBuff,
    )
    if err != nil {
        return PutWorkspacesWorkspaceIDTagsResponse{}, err
    }


    // add key auth header
	req.Header.Add("x-api-key", c.apiKey)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return PutWorkspacesWorkspaceIDTagsResponse{}, err
    }
    defer resp.Body.Close()

    statusErr := errorForStatus(*req, *resp)
	if statusErr != nil {
		return PutWorkspacesWorkspaceIDTagsResponse{}, statusErr
	}

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return PutWorkspacesWorkspaceIDTagsResponse{}, err
    }

    var castedBody PutWorkspacesWorkspaceIDTagsResponse
    err = json.Unmarshal(body, &castedBody)
    if err != nil {
        return PutWorkspacesWorkspaceIDTagsResponse{}, err
    }
    return castedBody, nil
}

